<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="windows-1251">
    <link rel="stylesheet" href="style.css">
    <link href="Labs/Lab_style.css" rel="stylesheet">
        </head>
        <body>
            <div id="container">
                <div id="navigation">
                    <a href="index.html">
                        <div class="nav_button">
                            <div class="nav_left"><img src="image/home.png"></div>
                            <div class="nav_right one">Главная</div>
                        </div>
                    </a>
                    <a href="info.html">
                        <div class="nav_button">
                            <div class="nav_left"><img src="image/instruct.png"></div>
                            <div class="nav_right one">Инструкции</div>
                        </div>
                    </a>
                    <a href="teory.html">
                        <div class="nav_button">
                            <div class="nav_left"><img src="image/library.png"></div>
                            <div class="nav_right two">Теоретический материал</div>
                        </div>
                    </a>
                    <a href="labs.html">
                        <div class="nav_button" style="color:#ff6a00">
                             <div class="nav_left"><img src="image/labs.png"></div>
                            <div class="nav_right two">Лабораторные работы</div>
                        </div>
                    </a>
                    <a href="adds.html">
                        <div class="nav_button">
                             <div class="nav_left"><img src="image/lupe.png"></div>
                            <div class="nav_right two">Дополнительные материалы</div>
                        </div>
                    </a>
                </div>

				
				
				<div class="left">
				<!--Навигация внутри страницы (якоря)-->
                    <div class="main header" style="margin: auto;">
                        <h1>Стуктурное тестирование</h1>
						<div class="local">
						<a href="#up"><div class="local_nav">Вверх</div></a>
						<a href="#down"><div class="local_nav">Вниз</div></a>
						<div class="local_nav_bord"></div>
						<a href="Lab3.html"><div class="local_nav">Следующая</div></a>
						<a href="Report/lab2_report.doc"><div class="local_nav">Отчет</div></a>
						<a href="Lab1.html"><div class="local_nav">Предыдущая</div></a>
						</div>
                    </div>					

                <div class="content" style="overflow: scroll;">
					<div class="incontent">

                        <div>
                            <h1 id="up" align=center>Лабораторная работа</h1>
                            <h1 align=center>Структурное тестирование</h1>
                            <p><b>Цель:</b> приобретение практических навыков тестирования
                                приложений с помощью структурного тестирования, а также приобретение навыков
                                разработки тестовых вариантов.</p>
                            <p>Структурное тестирование называют также тестированием по
                                «маршрутам», так как в этом случае тестовые наборы формируют путем анализа
                                маршрутов, предусмотренных алгоритмом. Под маршрутами при этом понимают
                                последовательности операторов программы, которые выполняются при конкретном
                                варианте исходных данных.</p>
                            <p>В основе структурного тестирования лежит концепция
                                максимально полного тестирования всех маршрутов программы. Так, если алгоритм
                                программы включает ветвление, то при одном наборе исходных данных может быть
                                выполнена последовательность операторов, реализующая действия, которые
                                предусматривает одна ветвь, а при втором - другая. Соответственно, для
                                программы будут существовать маршруты, различающиеся выбранным при ветвлении
                                вариантом.</p>
                            <p>Считают, что программа проверена полностью, если с помощью
                                тестов удается осуществить выполнение программы по всем возможным маршрутам
                                передач управления. Однако нетрудно видеть, что даже в программе среднего
                                уровня сложности число неповторяющихся маршрутов может быть очень велико, и,
                                следовательно, полное или исчерпывающее тестирование маршрутов, как правило,
                                невозможно.</p>
							<p><b>Общее задание</b></p>
                            <p>Разработать тестовые варианты для предложенного фрагмента кода.</p>
                            <p><b>Образец разработки тестовых вариантов</b></p>
                            <p>В качестве примера возьмем программу нахождения введенного с
                                клавиатуры числа Key среди элементов массива M размерности N с возвращением его
                                индекса I:</p>
                            <p style="text-align:center"><img width=646 height=240 src="Labs/Lab2.files/image001.jpg"></p>
                            <p>Структурное тестирование по способу тестирование базового пути основывается на построении и анализе путей потокового графа. </p>
                            <h2>Построение потокового графа</h2>
                            <p>Построение потокового графа на основе текста программы:</p>
                            <p>Нумеруются операторы текста, номера показаны в тексте
                                программы. К операторам текста относятся, начала и окончания условий, а также
                                операторы действий. После чего строится потоковый граф:</p>
                            <p style="text-align:center"><img width=414 height=201 src="Labs/Lab2.files/image002.jpg"></center></p>
                            <p>Определение цикломатической сложности</p>
                            <p>Определяем цикломатическую сложность V(G) потокового графа:</p>
                            <p>В начале, считается количество дуг и узлов. Каждая вершина
                                графа является узлом, а линии соединяющие узлы – ребра. После чего считаем</p>
                            <p><b>12 дуг – 10 узлов+2=4;</b></p>
                            <p>Далее посчитаем количество
                                предикатных узлов, то есть количество узлов, которые содержат условия. В данном
                                случае это узлы 2 и 6, так как они содержат условие цикла, и 7, так как в нем
                                находится условие ЕСЛИ. После нахождения всех узлов высчитаем по формуле:</p>
                            <p><b>f = количество предикатных узлов + 1.</b></p>
                            <p><b>3 предикатных узла + 1=4;</b></p>
                            <p>Определяем регионы потокового графа. Регион  - замкнутая область потокового графа.</p>
                            <p>Потоковый граф имеет 4 региона: R1, R2, R3, R4;</p>
                            <p>Так как три различных способа определения цикломатической
                                сложности показали одинаковое значение, значит существует четыре независимых
                                пути для данного потокового графа.</p>
                            <p></p>
							<p style="border:solid; border-color: #52999D;"><b>Задание 1:</b>
							<br>
							Самостоятельно откройте тестовое
                                приложение соответствующее вашему варианту и расчитайте цикломатическую мощность приложения. Вариант задания выбирается по последним двум цифрам в студенческом билете.
								 Тестовое приложение находится в папке "Programms".</p>
							
							<p>Определение базового множества независимых линейных путей</p>
                            <p>Независимым называют любой путь, который вводит новый
                                оператор обработки или условие. В терминах потокового графа независимый путь
                                должен содержать дугу, не входящую в ранее определенные пути.</p>
                            <p>Путь начинается в начальном узле, а заканчивается в конечном
                                узле графа. Независимые пути формируются в порядке от самого короткого к самому
                                длинному.</p>
                            <p>Каждый новый путь включает новую дугу. Все независимые пути
                                графа образуют базовое множество.</p>
                            <p>Определяем самый короткий путь. Из первого узла имеется
                                переход только во второй узел. Из второго узла есть несколько путей в узел 3 и
                                в узел 5. Так как узел 5 ближе к последнему узлу, то следует взять такие
                                входные данные, при которых условие в узле 2 будет выполнено, так чтобы перейти
                                в узел 5. Далее переход в узел 6, в котором аналогично узлу 2 подбираем входные
                                параметры, при которых условие будет выполнено так, чтобы перейти в узел 10. На
                                этом путь закончен.</p>
                            <p><b>Путь 1: 1-2-5-6-10;</b></p>
                            <p>Определяем следующий путь. Для этого пройдем до 6 узла, так
                                же как в предыдущем пути. Далее пройдем к 7 узлу. В данном случае есть два
                                пути, выберем самый длинный через 8 до 9. После чего вернемся в узел 6, а из него
                                до 10.</p>
                            <p><b>Путь 2: 1-2-5-6-7-8-9-6-10;</b></p>
                            <p>Для определения следующего пути необходимо захватить путь
                                через узлы 3 и 4, так как они не были в предыдущих путях. После завершения
                                отрезка 1-2-3-4-2-5-6, перейдем к узлу 7, а из него перейдем сразу к узлу 9,
                                так как эта дуга не будет захвачена последующим путем.</p>
                            <p><b>Путь 3: 1-2-3-4-2-5-6-7-9-6-10;</b></p>
                            <p>Далее находим самый длинный путь. В данном случае необходимо
                                подобрать путь, который будет проходить через все узлы графа.</p>
                            <p><b>Путь 4: 1-2-3-4-2-5-6-7-8-9-6-10.</b></p>
							
							<p style="border:solid; border-color: #52999D;"><b>Задание 2:</b>
							<br>Расчитайте базовое множество независимых линейных путей для вашего приложения.</p>
							
                            <p><b>Подготовка тестовых вариантов</b></p>
                            <p>На данном этапе подготавливаются тестовые варианты, которые
                                обеспечат такие результаты условий, при которых будут пройдены все 4 пути,
                                найденные в предыдущем этапе.</p>
                            <p><b>Тестовый вариант№1</b>:</p>
                            <p>Для того чтобы условие цикла i&lt;N было неверным, необходимо, чтобы переменная i,
                                которая равна0, была больше, чем N,
                                в данном случае подбираем самое наибольшее из целочисленных значений меньше 0.
                                Так как оба цикла имеют одно и тоже условие, то оба цикла будут игнорироваться.
                                Следовательно сравнение Key проходит в циклах, то
                                следовательно, можно выбрать любое значение переменной Key,
                                так как она не будет сравнена. Результат теста будет отрицательный, то есть I=0.</p>
                            <p><b>Идентификатор:</b> N= -1, Key=любое;<br>
							<b>Ожидаемый результат: </b>I=0.</p>
                            <p><b>Тестовый вариант№2</b>:</p>
                            <p>Для того чтобы условие цикла i&lt;N
                                было не верным, необходимо, чтобы переменная i, которая равна 0, была меньше или равна N.
                                В данном случае подбираем самое наименьшее из целочисленных значений меньше 0.
                                Так как оба цикла имеют одно и тоже условие, то оба цикла будут проигнорированы.
                                Так как мы знаем значение M[i],
                                то для того, чтобы тест прошел необходимо чтобы Key
                                была равна M[i]. Но результат
                                теста будет отрицательный, то есть I=0, так как второй
                                цикл не пройдет, потому что значение N не даст пройти
                                обоим циклам.</p>
                            <p><b>Идентификатор:</b> N=0, Key=M[1];<br>
							<b>Ожидаемый результат: </b>I=0;</p>
                            <p><b>Тестовый вариант№3</b>:</p>
                            <p>Для того чтобы условие цикла i&lt;N было верным, необходимо, чтобы переменная i,
                                которая равна 0, была меньше, чем N. В данном случае
                                подбираем самое наименьшее из целочисленных значений меньше 0. Так как оба
                                цикла имеют одно и тоже условие, то оба цикла будут пройдут. Так как мы знаем
                                значение M[i], то для того,
                                чтобы тест не прошел необходимо чтобы Key была не равна
                                M[i]. Результат теста будет
                                отрицательный, то есть I=0.</p>
                            <p><b>Идентификатор:</b> N=1, Key;M[1];<br>
							<b>Ожидаемый результат:</b>I=0;</p>
                            <p><b>Тестовый вариант№4</b>:</p>
                            <p>Для того чтобы условие цикла i&lt;N было верным, необходимо, чтобы переменная i,
                                которая равна 0, была меньше, чем N. В данном случае
                                подбираем самое наименьшее из целочисленных значений меньше 0. Так как оба
                                цикла имеют одно и тоже условие, то оба цикла будут пройдут. Так как мы знаем
                                значение M[i], то для
                                прохождения теста необходимо чтобы Key была равна M[i]. Результат теста будет
                                положительный, то есть I=1.</p>
                            <p><b>Идентификатор:</b> N=1, Key=M[1];<br>
							<b>Ожидаемый результат: </b>I=1;</p>
							
							<p style="border:solid; border-color: #52999D;"><b>Задание 3:</b>
							<br>На основе базового множества независимых линейных путей составьте тестовые варианты для вашего приложения.</p>
							
							<hr size=3 width=90% color=black>
                            <h2 id="end">Контрольное задание</h2>
                            <p id="down">Самостоятельно откройте тестовое
                                приложение соответствующее вашему варианту и создайте и проведите структурное
                                тестирование приложения. Вариант задания выбирается по последним двум цифрам в студенческом билете. Полученные данные занесите в <a class="report" href="Report/lab2_report.doc">отчет</a> о тестировании.  Тестовое приложение находится в папке "Programms".</p>
                        </div>
                    </div>
				</div>
				</div>
				</div>
            </div>
         </body>
        </html>
