<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="windows-1251">
    <link rel="stylesheet" href="style.css">
    <link href="Labs/Lab_style.css" rel="stylesheet">
        </head>
        <body>
            <div id="container">
                <div id="navigation">
                    <a href="index.html">
                        <div class="nav_button">
                            <div class="nav_left"><img src="image/home.png"></div>
                            <div class="nav_right one">Главная</div>
                        </div>
                    </a>
                    <a href="info.html">
                        <div class="nav_button">
                            <div class="nav_left"><img src="image/instruct.png"></div>
                            <div class="nav_right one">Инструкции</div>
                        </div>
                    </a>
                    <a href="teory.html">
                        <div class="nav_button"  style="color:#ff6a00">
                            <div class="nav_left"><img src="image/library.png"></div>
                            <div class="nav_right two">Теоретический материал</div>
                        </div>
                    </a>
                    <a href="labs.html">
                        <div class="nav_button">
                             <div class="nav_left"><img src="image/labs.png"></div>
                            <div class="nav_right two">Лабораторные работы</div>
                        </div>
                    </a>
                    <a href="adds.html">
                        <div class="nav_button">
                             <div class="nav_left"><img src="image/lupe.png"></div>
                            <div class="nav_right two">Дополнительные материалы</div>
                        </div>
                    </a>
                </div>
	
					
					
					<div class="left">			
								<!--Навигация внутри страницы (якоря)-->
                    <div class="main header" style="margin: auto;">
                        <h1>Модульное тестирование</h1>
						<div class="local">
						<a href="#up"><div class="local_nav">Вверх</div></a>
						<a href="#down"><div class="local_nav">Вниз</div></a>
						<div class="local_nav_bord"></div>
						<a href="teory5.html"><div class="local_nav">Следующая тема</div></a>
						<a href="#norecommend"><div class="local_nav">Недостатки использования</div></a>
						<a href="#recommend"><div class="local_nav">Причины использования</div></a>
						<a href="#definition"><div class="local_nav">Определение</div></a>
						<a href="teory3.html"><div class="local_nav">Предыдущая тема</div></a>
						</div>
                    </div>
                <div class="content" style="overflow: scroll;">
					<div class="incontent">
                        
						<h1 id="up">Модульное тестирование</h1>

						<p id="definition"><b>Модульное тестирование</b>, или <b>юнит-тестирование</b>
						(англ.<i>unit testing</i>)—
						процесс в программировании, позволяющий проверить на
						корректность отдельные модули исходного кода программы. Идея состоит в том,
						чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет
						достаточно быстро проверить, не привело ли очередное изменение кода к <i>регрессии</i>,
						то есть к появлению ошибок в уже оттестированных местах программы, а также
						облегчает обнаружение и устранение таких ошибок.</p>
						
						<p><b>Цель модульного тестирования</b> — изолировать отдельные
						части программы и показать, что по отдельности эти части работоспособны.</p>
						
						<p><b>Модульные тесты</b> – это тесты, которые проверяют корректность
						работы отдельной функции или метода. Модульные тесты обычно пишутся
						программистами и служат для первичной проверки того, что внесенные изменения не
						изменили поведение отдельных компонентов системы.</p>

						<p>Один из наиболее эффективных подходов к модульному
						тестированию - это <b>подготовка автоматизированных тестов</b> до начала
						основного разработки программного обеспечения. При этом подходе создаются и
						интегрируются небольшие куски кода, напротив которых запускаются тесты,
						написанные до начала кодирования. Разработка ведется до тех пор
						пока все тесты не будут успешно пройдены.</p>
						
						<p>Модульные тесты используются при разработке программного
						обеспечения. Они могут быть созданы как после написания исходного кода, так и
						до этого, все зависит политики компании или желания самого программиста. В
						большинстве случаев модульное тестирование осуществляется самим программистом,
						а не специалистом по тестированию. Также в большинстве случает
						используются инструментарий представленный средой разработки, а не
						специализированные инструменты.</p>

						<h2 id="recommend">Причины использования модульного тестирования.</h2>

						<p><b>Поощрение	изменений</b> - Модульное тестирование позже позволяет программистам
						проводить рефакторинг, будучи уверенными, что модуль
						по-прежнему работает корректно, на основе регрессивного тестирования. Это
						поощряет программистов к изменениям кода, поскольку достаточно легко проверить,
						что код работает и после изменений.</p>

						<p><b>Регрессионное
						тестирование</b> — собирательное название для всех видов тестирования
						программного обеспечения, направленных на обнаружение ошибок в уже
						протестированных участках исходного кода.</p>

						<p><b>Упрощение интеграции</b> - модульное тестирование
						помогает устранить сомнения по поводу отдельных модулей и может быть
						использовано для подхода к тестированию «снизу вверх»: сначала тестируя
						отдельные части программы, а затем программу в целом.</p>

						<p><b>Документирование кода</b> - модульные тесты можно
						рассматривать как документацию для тестируемого класса. Клиенты, которые не
						знают, как использовать данный класс, могут использовать юнит-тест в качестве
						примера.</p>

						<p><b>Отделение интерфейса от реализации</b> - поскольку некоторые классы
						могут использовать другие классы, тестирование отдельного класса часто
						распространяется на связанные с ним. Например, класс
						пользуется базой данных; в ходе написания теста программист обнаруживает, что
						тесту приходится взаимодействовать с базой. Это ошибка, поскольку тест не
						должен выходить за границу класса. В результате разработчик абстрагируется от
						соединения с базой данных и реализует этот интерфейс, используя свой
						собственный объект. Это приводит к менее связанному коду, минимизируя
						зависимости в системе.<p>

						<h2 id="norecommend">Когда модульное тестирование не работает</h2>

						<p><b>Сложный код</b> - тестирование программного
						обеспечения— комбинаторная задача. Например, каждое возможное значение
						булевской переменной потребует двух тестов: один на вариант TRUE, другой—
						на вариант FALSE. В результате на каждую строку исходного кода потребуется
						3-5 строк тестового кода.</p>

						<p>Как и любая технология тестирования, модульное тестирование не позволяет
						отловить все ошибки программы. В самом деле, это следует из практической
						невозможности трассировки всех возможных путей выполнения программы, за
						исключением простейших случаев.</p>

						<p><b>Результат известен лишь приблизительно</b> - например, в математическом
						моделировании. Бизнес-приложения зачастую работают с конечными
						и счётными множествами, научные— с континуальными. Поэтому сложно
						подобрать тесты для каждой из ветвей программы, сложно сказать, верен ли
						результат, выдерживается ли точность, итакдалее. А во многих
						случаях качество моделирования определяется «на глаз», и последний результат
						записывается как «опорный». Если найдено расхождение, новый результат проверяют
						вручную и выясняют, какой качественнее: старый или новый.</p>

						<p><b>Ошибки интеграции и производительности</b> - кроме того, происходит
						тестирование каждого из модулей по отдельности. Это означает, что ошибки
						интеграции, системного уровня, функций, исполняемых в нескольких модулях, не
						будут определены. Кроме того, данная технология бесполезна для проведения
						тестов на производительность. Таким образом, модульное тестирование более
						эффективно при использовании в сочетании с другими методиками тестирования.</p>

						<p id="down"><b>При общей низкой культуре программирования</b> - для получения выгоды от
						модульного тестирования требуется строго следовать технологии тестирования на
						всём протяжении процесса разработки программного обеспечения. Нужно хранить не
						только записи обо всех проведённых тестах, но и обо всех изменениях исходного
						кода во всех модулях. С этой целью следует использовать систему контроля версий
						программного обеспечения. Таким образом, если более поздняя версия программного
						обеспечения не проходит тест, который был успешно пройден ранее, будет
						несложным сверить варианты исходного кода и устранить ошибку. Также необходимо
						убедиться в неизменном отслеживании и анализе неудачных тестов. Игнорирование
						этого требования приведёт к лавинообразному увеличению неудачных тестовых
						результатов.</p>

					</div>
					<div>
            </div>
        </div>
	</body>
</html>
