<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="windows-1251">
    <link rel="stylesheet" href="style.css">
    <link href="Labs/Lab_style.css" rel="stylesheet">
        </head>
        <body>
            <div id="container">
                <div id="navigation">
                    <a href="index.html">
                        <div class="nav_button">
                            <div class="nav_left"><img src="image/home.png"></div>
                            <div class="nav_right one">Главная</div>
                        </div>
                    </a>
                    <a href="info.html">
                        <div class="nav_button">
                            <div class="nav_left"><img src="image/instruct.png"></div>
                            <div class="nav_right one">Инструкции</div>
                        </div>
                    </a>
                    <a href="teory.html">
                        <div class="nav_button"  style="color:#ff6a00">
                            <div class="nav_left"><img src="image/library.png"></div>
                            <div class="nav_right two">Теоретический материал</div>
                        </div>
                    </a>
                    <a href="labs.html">
                        <div class="nav_button">
                             <div class="nav_left"><img src="image/labs.png"></div>
                            <div class="nav_right two">Лабораторные работы</div>
                        </div>
                    </a>
                    <a href="adds.html">
                        <div class="nav_button">
                             <div class="nav_left"><img src="image/lupe.png"></div>
                            <div class="nav_right two">Дополнительные материалы</div>
                        </div>
                    </a>
                </div>
	
				
				
				<div class="left">
								<!--Навигация внутри страницы (якоря)-->
                    <div class="main header" style="margin: auto;">
                        <h1>Структурное тестирование</h1>
						<div class="local">
						<a href="#up"><div class="local_nav">Вверх</div></a>
						<a href="#down"><div class="local_nav">Вниз</div></a>
						<div class="local_nav_bord"></div>
						<a href="teory3.html"><div class="local_nav">Следующая тема</div></a>
						<a href="#circle"><div class="local_nav">Циклы</div></a>
						<a href="#if"><div class="local_nav">Ветвления</div></a>
						<a href="#base"><div class="local_nav">Базовый путь</div></a>
						<a href="teory1.html"><div class="local_nav">Предыдущая тема</div></a>
						</div>
                    </div>
                <div class="content" style="overflow: scroll;">
					<div class="incontent">
                        <h1 id="up">Структурное тестирование программного обеспечения</h1>

                        <h2>Основные понятия и принципы тестирования ПО</h2>
                        <p><b>Тестирование</b> — процесс выполнения программы с целью обнаружения ошибок. Шаги процесса задаются тестами.</p>
						<p>Каждый тест определяет:</p>
						<ul>
							<li>свой набор исходных данных и условий для запуска программы;</li>
							<li>набор ожидаемых результатов работы программы.</li>
						</ul>
                        <p> Другое название теста — тестовый вариант. Полную проверкупрограммы гарантирует <i>исчерпывающее тестирование. </i>Оно требует проверить всенаборы исходных данных, все варианты их обработки и включает большое количествотестовых вариантов. Исчерпывающее тестирование во многих случаяхзатруднительно, поскольку срабатывают ресурсные ограничения (прежде всего,ограничения по времени).</p>
                        <p>Хорошим считают тестовый вариант с высокой вероятностьюобнаружения еще не раскрытой ошибки. Успешным называют тест, которыйобнаруживает до сих пор не раскрытую ошибку.</p>
						<p><b>Целью проектирования тестовых вариантов</b> является систематическое обнаружение различных классов ошибок при минимальных затратахвремени и стоимости.</p>
                        <p>Тестирование обеспечивает:</p>
						<ul>
							<li>обнаружение ошибок;</li>
							<li>демонстрацию соответствия функций программы ее назначению;</li>
							<li>демонстрацию реализации требований к характеристикам программы;</li>
							<li>отображение надежности как индикатора качества программы.</li>
						</ul>
                        <p>Тестирование не может показать отсутствия</p>
                        <p>Рассмотрим информационные потоки процесса тестирования. Они показаны на рис.1.</p>
                        <p style="text-align:center"><img width=464 height=180 src="teory/teory2.files/image001.jpg"></p>
                        <p style="text-align:center">Рис. 1. Информационные потоки процесса тестирования</p>
                        <p>На входе процесса тестирования три потока:</p>
						<ul>
							<li>текст программы;</li>
							<li>исходные данные для запуска программы;</li>
							<li>ожидаемые результаты.</li>
						</ul>
                        <p>Выполняются тесты, все полученныерезультаты оцениваются. Это значит, что реальные результаты тестов сравниваютсяс ожидаемыми результатами. Когда обнаруживается несовпадение, фиксируется ошибка— начинается отладка. Процесс отладки непредсказуем по времени. На поиск местадефекта и исправление может потребоваться час, день, месяц. Неопределенность вотладке приводит к большим трудностям в планировании действий.</p>
                        <p>После сбора и оцениваниярезультатов тестирования начинается отображение качества и надежности ПО. Еслирегулярно встречаются серьезные ошибки, требующие проектных изменений, то качествои надежность ПО подозрительны, констатируется необходимость усилениятестирования. С другой стороны, если функции ПО реализованы правильно, аобнаруженные ошибки легко исправляются, может быть сделан один из двух выводов:</p>
                        <ul>
							<li>качество и надежность ПО удовлетворительны;</li>
							<li>тесты не способны обнаруживать серьезные ошибки.</li>
						</ul>
                        <p>В конечном счете, если тесты не обнаруживаютошибок, появляется сомнение в том, что тестовые варианты достаточно продуманы ичто в ПО нет скрытых ошибок. Такие ошибки будут, в конечном итоге,обнаруживаться пользователями и корректироваться разработчиком на этапе сопровождения(когда стоимость исправления возрастает в 60-100 раз по сравнению с этапомразработки).</p>
                        <p>Результаты, накопленные в ходетестирования, могут оцениваться и более формальным способом. Для этогоиспользуют модели надежности ПО, выполняющие прогноз надежности по реальным даннымоб интенсивности ошибок.</p>
                        <p>Существуют 2 принципа тестирования программы:</p>
                        <ul>
							<li>функциональное тестирование(тестирование «черного ящика»);</li>
							<li>структурное тестирование (тестирование «белого ящика»).</li>
						</ul>
                        <p>Тестирование «белого ящика»</p>
                        <p>Известна: внутренняя структура программы.</p>
                        <p>Исследуются: внутренние элементы программы и связи междуними (рис. 2).</p>
                        <p style="text-align:center"><img width=406 height=203 src="teory/teory2.files/image002.jpg"></p>
                        <p style="text-align:center">Рис. 2. Тестирование «белого ящика»</p>
                        <p>Объектом тестирования здесьявляется не внешнее, а внутреннее поведение про граммы. Проверяетсякорректность построения всех элементов программы и правильность ихвзаимодействия друг с другом. Обычно анализируются управляющие связи элементов,реже — информационные связи. Тестирование по принципу «белого ящика»характеризуется степенью, в какой тесты выполняют или покрывают логику(исходный текст) программы. Исчерпывающее тестирование также затруднительно.Особенности этого принципа тестирования рассмотрим отдельно.</p>
                        <p>Особенности тестирования «белого ящика»</p>
                        <p>Обычно тестирование «белого ящика»основано на анализе управляющей структуры программы. Программа считаетсяполностью проверенной, если проведено исчерпывающее тестирование маршрутов(путей) ее графа управления.</p>
                        <p>В этом случае формируются тестовые варианты, в которых:</p>
						<ul>
							<li>гарантируется проверка всех независимыхмаршрутов программы;</li>
							<li>проходятся ветви True,False для всех логических решений;</li>
							<li>выполняются все циклы (в пределах их границ и диапазонов);</li>
							<li>анализируется правильность внутренних структур данных.</li>
						</ul>
                        <p>Недостатки тестирования «белого ящика»:</p>
						<ol>
							<li>Количество независимых маршрутов может быть очень велико. Например, если цикл в программе выполняется <i>k</i>раз, а внутри цикла имеется <i>n</i> ветвлений, то количество маршрутов вычисляется по формуле
                        <p style="text-align:center"><img width=169 height=57 src="teory/teory2.files/image003.jpg"></p>
                        <p>При <i>n </i>= 5 и <i> k = </i> 20 количество маршрутов <i>т </i>= 10<sup>14</sup>. Примем,что на разработку, выполнение и оценку теста по одному маршруту расходуется 1мс. Тогда при  работе 24 часа в сутки 365 дней в году на тестирование уйдет 3170 лет.</li>
							<li>Исчерпывающее тестирование маршрутов не гарантирует соответствия программы исходным требованиям к ней.</li>
							<li>В программе могут быть пропущены некоторые маршруты.</li>
							<li>Нельзя обнаружить ошибки, появление которых зависит от обрабатываемых  данных (это ошибки, обусловленныевыражениями типа if abs(a-b); eps...,
                        <p><b>if(a+b+c)/3=a...).</b></p></li>
						</ol>
                        
                        
                        
                        
						<p>Достоинства тестирования «белого ящика» связаны с тем, что принцип «белого ящика» позволяет учесть особенности программных ошибок:</p>
						<ol>
							<li>Количество ошибок минимально в «центре» и максимально на «периферии» программы.</li>
							<li>Предварительные предположения овероятности потока управления или данных в программе часто бывают некорректны.В результате типовым может стать маршрут, модель вычислений по которомупроработана слабо.</li>
							<li>При записи алгоритма ПО в виде текстана языке программирования возможно внесение типовых ошибок трансляции(синтаксических и семантических).</li>
							<li>Некоторые результаты в программе зависят не от исходных данных, а от внутренних состояний программы.</li>
						</ol>
                        <p>Каждая из этих причин является аргументом для проведения тестирования по принципу «белого ящика». Тесты «черного ящика» не смогут реагировать на ошибки таких типов.</p>
                        <h3 id="base">Способ тестирования базового пути</h3>
                        <p><b>Тестирование базового пути — </b> это способ, который основан на принципе «белого ящика». Автор этого способа — Том МакКейб (1976).</p>
                        <p>Способ тестирования базового пути дает возможность:</p>
						<ul>
							<li>получить оценку комплексной сложности программы;</li>
							<li>использовать эту оценку для определения необходимого количества тестовых вариантов.</li>
						</ul>
                        <p>Тестовые варианты разрабатываются для проверки базового множества путей (маршрутов) в программе. Они гарантируют однократное выполнение каждого опера тора программы при тестировании.</p>
                        <h3>Потоковый граф</h3>
                        <p>Для представления программыиспользуется потоковый граф. Перечислим его особенности:</p>
						<ol>
							<li>Граф строится отображением управляющейструктуры программы. В ходе отображения закрывающие скобки условных операторови операторов циклов (end if;end loop) рассматриваются как отдельные (фиктивные) операторы.</li>
							<li>Узлы (вершины) потокового графа соответствуют линейным участкам программы, включают один или несколько операторов программы.</li>
							<li>Дуги потокового графа отображают поток управления в программе (передачи управления между операторами). Дуга — это ориентированное ребро.</li>
							<li>Различают операторные и предикатные узлы. Из операторного узла выходит одна дуга, а из предикатного — две дуги.</li>
						</ol>
                        <p>Предикатные узлы соответствуют простым условиям в программе. Составное условие программы    отображается в несколько предикатных узлов. Составным называют условие, в    котором используется одна или несколько булевых операций (OR, AND).
                        <p>Например, фрагмент программы:</p>
                        <p>If a OR b</p>
                        <p>then x </p>
                        <p>else у</p>
                        <p>end If;</p>
                        <p>вместо прямого отображения в потоковый граф вида, показанного на рис. 4, отображается в преобразованный потоковый граф (рис.5).</p>
                        <p style="text-align:center"><img width=200 height=175 src="teory/teory2.files/image004.jpg"><img width=167 height=213 src="teory/teory2.files/image005.jpg"></p>
                        <p style="text-align:center">Рис.4-5. Преобразованный потоковый граф.</p>
                        <p>Замкнутые области, образованные дугами и узлами, называют регионами.</p>
                        <p>Окружающая граф среда рассматривается как дополнительный регион. Например, показанный здесь граф имеет три региона — Rl, R2, R3,</p>
                        <p><b>Пример 1.</b> Рассмотрим процедуру сжатия:</p>
						<p>процедура сжатия</p>
                        <p>1 выполнять пока нет EOF</p>
                        <p>1 читать запись;</p>
                        <p>2 если запись пуста</p>
                        <p>3 то удалить запись;</p>
                        <p>4 иначе если поле а; = поля b </p>
                        <p>5 то удалить b;</p>
						<p>6 иначе удалить а;</p>
                        <p>7а конец если;</p>
                        <p>7b  конец выполнять;</p>
                        <p>8 конец сжатие;</p>
                        <p style="text-align:center"><img width=154 height=293 src="teory/teory2.files/image006.jpg"></p>
                        <p style="text-align:center">Рис.6. Преобразованный потоковый граф процедуры сжатия</p>
                        <p>Она отображается в потоковый граф, представленный на рис.6. Видим, что этот потоковый граф имеет четыре региона.</p>						<h3>Цикломатическая сложность</h3>
                        <p><b>Цикломатическая сложность</b> — метрика ПО, котораяобеспечивает количественную оценку логической сложности программы. В способетестирования базового пути Цикломатическая сложность определяет:    </p>
                        <ul>
							<li>количество независимых путей в базовом множестве программы;</li>
							<li>верхнюю оценку количества тестов, которое гарантирует однократное выполнение всех операторов.</li>
						</ul>
                        <p>Независимым называется любой путь,который вводит новый оператор обработки или новое условие. В терминахпотокового графа независимый путь должен со­держать дугу, не входящую в ранееопределенные пути.</p>
                       <p>Путь начинается в начальномузле, а заканчивается в конечном узле графа. Независимые пути формируются впорядке от самого короткого к самому длинному.</p>
                        <p style="text-align:center"><img width=154 height=293 src="teory/teory2.files/image007.jpg"></p>
                        <p>Перечислим независимые пути для потокового графа из примера1:</p>
                        <p><b>Путь1: 1-8.</b></p>
                        <p><b>Путь 2: 1-2-3-7а-7b-1-8.</b></p>
                        <p><b>ПутьЗ: 1-2-4-5-7а-7b-1-8.</b></p>
                        <p><b>Путь 4: 1-2-4-6-7а-7b-1-8.</b></p>
                        <p>Заметим, что каждый новый путь включает новую дугу. Все независимые пути графа образуют базовое множество.</p>
                        <p><b>Свойства базового множества:</b></p>
						<ol>
							<li>Тесты, обеспечивающие его проверку, гарантируют:</li>
							<ul>
								<li>однократное выполнение каждого оператора;</li>
								<li>выполнение каждого условия по True - ветви и по False - ветви.</li>
							</ul>
							<li>Мощность базового множества равна цикломатической сложности потокового графа.</li>
						</ol>
                        <p>Цикломатическая сложность вычисляется одним из трех способов:</p>
						<ol>
							<li>цикломатическая сложность равна количеству регионов потокового графа;</li>
							<li>цикломатическая сложность определяется по формуле:</p>
                        <p><b>V(G)=EN+2</b>, где <b>Е — </b>количество дуг, <b>N — </b> количество узлов потокового графа;</p></li>
							<li>цикломатическая сложность формируется по выражению <b>V(G) =p+1 </b>, где р — количество предикатных узлов в потоковом графе<b>G</b>.</li>
						</ol>
                        <p>Вычислим цикломатическую сложность графа из примера 1 каждым из трех способов:</p>
						<ol>
							<li>потоковый граф имеет 4 региона;</li>
							<li><b>V(G) </b>- 11 дуг - 9 узлов + 2 = 4;</li>
							<li><b>V(G) </b> - 3 предикатных узла +1=4.</li>
						</ol>
                        <p>Таким образом, цикломатическая сложность потокового графа из примера 1 равна четырем.</p>
                        <p>Шаги способа тестирования базового пути</p>
                        <p>Для иллюстрации шагов данногоспособа используем конкретную программу Процедуру вычисления среднего значения:</p>
                        <p>Процедура сред: </p>
                        <p>1   i:= 1:</p>
                        <p>1   введено :=0; </p>
                        <p>1   колич := 0; </p>
                        <p>1   сум := 0;          </p>
                        <p>вып пока 2-    вел(>i )  stop и введено = 500  -3</p>
                        <p>4 ведено:= веденo_+_ 1;</p>
                        <p>если 5  вел (i)=мин и вел( i) = макс 6</p>
                        <p>7 то колич :=колич+ 1; 7  сум := сум + вел( i );</p>
                        <p>8  конец если;</p>
                        <p>8  i:=i+ 1; </p>
                        <p>9  конец вып; </p>
                        <p>10 если колич  О</p>
                        <p>11  то сред := сум / колич;</p>
                        <p>12  иначе сред := stop; </p>
                        <p>13 конец если; </p>
                        <p>13 конец сред;</p>
                        <p>Заметим, что процедура содержит составные условия(в заголовке цикла и условном операторе).</p>
                        <p><b>Шаг 1.</b>На основе текста программы формируется потоковый граф:</p>
                        <ul>
							<li>нумеруются операторы текста (номера операторов показаны в тексте процедуры);</li>
							<li>производится отображение пронумерованного текста программы в узлы и вер­шины потокового графа (рис. 7).</li>
						</ul>
						<p style="text-align:center"><img width=210 height=265 src="teory/teory2.files/image008.jpg"></p>
                        <p style="text-align:center">Рис. 7. Потоковый граф процедуры вычисления среднего значения</p>
                        <p><b>Шаг 2. </b> Определяется цикломатическая сложность потокового графа — по каждой из трех формул:</p>
						<ol>
							<li><b>V(G) </b>= 6 регионов;</li>
							<li><b>V(G) </b>= 17 дуг - 13 узлов + 2 = 6;</li>
							<li><b>V(G) </b>= 5 предикатных узлов + 1 = 6.</li>
						</ol>
                        <p><b>Шаг 3. </b>Определяется базовое множество независимых линейных путей:</p>
                        <p>Путь 1: 1-2-10-11-13; /вел=</p>
                        <p>Путь 2: 1-2-10-12-13; /вел=</p>
                        <p>Путь 3: 1-2-3-10-11-13; /попытка обработки 501-й величины.</p>
                        <p>Путь 4: 1-2-3-4-5-8-9-2-... /велмин.</p>
                        <p>Путь 5: 1-2-3-4-5-6-8-9-2-... /велмакс.</p>
                        <p>Путь 6: 1-2-3-4-5-6-7-8-9-2-... /режим нормальной обработки.</p>
                        <p>Для удобства дальнейшего анализа покаждому пути указаны условия запуска. Точки в конце путей 4, 5, 6 указывают,что допускается любое продолжение через остаток уп­равляющей структуры графа.</p>
                        <p><b>Шаг 4. </b>Подготавливаются тестовые варианты, инициирующие выполнение каждого пути.</p>
                        <p>Каждый тестовый вариант формируется в следующем виде: Исходные данные (ИД): Ожидаемые результаты (ОЖ.РЕЗ.):</p>
                        <p>Исходные данные должны выбиратьсятак, чтобы предикатные вершины обеспечивали нужные переключения — запуск толькотех операторов, которые перечислены в конкретном пути, причем в требуемомпорядке.</p>
                        <p>Определим тестовые варианты,удовлетворяющие выявленному множеству независимых путей.</p>
                        <p>Тестовый вариант для пути 1 ТВ1:</p>
                        <p><b>ИД:</b>вел(k) = допустимое значение, где <b>k i</b>;вел(i) = stop, где 2 i 500.</p>
                        <p><b>ОЖ.РЕЗ.: </b>корректное усреднение основывается на <b>k</b> величинах и правильном подсчете.</p>
                        <p>Путь не может тестироватьсясамостоятельно, а должен тестироваться как часть путей 4, 5, 6 (трудностипроверки 11 -го оператора).</p>
                        <p>Тестовый вариант для пути 2 ТВ2:</p>
                        <p><b>ИД:</b>вел(1)=stор.</p>
                        <p><b>ОЖ.РЕЗ.: </b>сред=stор, другие величины имеют начальные значения. Тестовый вариант для пути 3 ТВЗ:</p>
                        <p><b>ИД: </b> попытка обработки 501-й величины, первые 500 величин должныбыть правильными.</p>
                        <p><b>ОЖ.РЕЗ</b>:. корректное усреднение основывается на <b>k</b> величинах и правильном подсчете.</p>
                        <p>Тестовый вариант для пути 4 ТВ4: ИД: вел(i)=допустимое значение, где<b> i</b> 500; вел()  мин, где<b> k i</b>.</p>
                        <p><i>ОЖ.РЕЗ.: </i>корректное усреднение основывается на<i> k  </i><i> </i>величинах и правильном подсчете. </p>
                        <p>Тестовый вариант для пути 5 ТВ5:
                        </p>
                        <p>ИД: вел(i)=допустимое значение, где<i> i
                            </i><i> </i> 500; вел(&pound;)  макс, где<i> k </i><i> </i><i> </i><i>i </i><i>.</i></p>
                        <p><i>ОЖ.РЕЗ.: </i>корректное усреднение основывается на <i>п </i>величинах и правильном подсчете.</p>
                        <p>Тестовый вариант для пути 6 ТВ6:</p>
                        <p>ИД.вел(i)=допустимое значение, где<i> i</i><i> </i><i></i>500.</p>
                        <p><i>ОЖ.РЕЗ.: </i>корректное усреднение основывается на <i>п </i>величинах иправильном подсчете.</p>
                        <p >Реальные результаты каждоготестового варианта сравниваются с ожидаемыми результатами. После выполнениявсех тестовых вариантов гарантируется, что все операторы программы выполнены поменьшей мере один раз.</p>
                        <p>Важно отметить, что некоторые независимые пути не могутпроверяться изолированно. Такие пути должны проверяться при тестированиидругого пути (как часть другого тестового варианта).</p>
                        <p>Способы тестирования условий</p>
						<p>Цель этого семейства способовтестирования — строить тестовые варианты для проверки логических условийпрограммы. При этом желательно обеспечить охват операторов из всех ветвей программы.</p>
                        <p>Рассмотрим используемую здесь терминологию.</p>
                        <p>Простое условие — булева переменная или выражение отношения.</p>
                        <p>Выражение отношения имеет вид</p>
                        <p>Е1 «оператор отношения» Е2,</p> где El, E 2 — арифметические выражения, а в качестве оператора отношения используется один изследующих операторов: , , =, =, =.</p>

                        <p>Составное условие состоит изнескольких простых условий, булевых операторов и круглых скобок применяются булевы операторы
                            OR,AND(),NOT. Условия, не содержащие выражений отношения, называютбулевыми выражениями.</p>
                        <p>Таким образом, элементами условияявляются: булев оператор, булева переменная, пара скобок (заключающая простоеили составное условие), оператор отношения, арифметическое выражение. Эти элементы определяют типы ошибок в условиях.</p>
                        <p>Если условие некорректно, тонекорректен по меньшей мере один из элементов условия. Следовательно, в условии возможны следующие типы ошибок:</p>
                        <ul>
							<li>ошибка булева оператора (наличие некорректных / отсутствующих / избыточных булевых операторов);</li>
							<li>ошибка булевой переменной;</li>
							<li>ошибка булевой скобки;</li>
							<li>ошибка оператора отношения;</li>
							<li>ошибка арифметического выражения.</li>
						</ul>

                        <p>Способ тестирования условий ориентирован на тестирование каждого условия в программе. Методики тестированияусловий имеют два достоинства. Во-первых достаточно просто выполнить измерение тестового покрытия условия. Во-вторых тестовое покрытие условий в программе —это фундамент для генерации дополнительных тестов программы.</p>

                        <p><b>Целью тестирования условий</b> является определение не только ошибок в условиях, но и других ошибок в программах. Еслинабор тестов для программы А эффективен для обнаружения ошибок в условиях,содержащихся в А, то вероятно, что этот набор также эффективен для обнаружениядругих ошибок в А. Кроме того, если методика тестирования эффективна дляобнаружения ошибок в условии, то вероятно, что эта методика будет эффективнадля обнаружения ошибок в программе.</p>

                        <p>Существует несколько методик тестирования условий.</p>
                        <p><b>Простейшая методика</b> — <i>тестирование ветвей.</i>Здесь для составного условия <i>С </i>проверяется каждое простоеусловие (входящее в него); True-ветвь;False-ветвь.</p>
                        <p><b>Другая методика</b> — <i> тестирование области определения.</i>В ней для выражения отношения требуется генерация 3-4тестов. Выражение вида Е1 «оператор отношения» Е2проверяется тремя тестами, которыеформируют значение Е1 большим, чем Е2, равным Е2 и меньшим, чем Е2.</p>
                        <p>Если оператор отношения неправилен,а Е1 и Е2 корректны, то эти три теста гарантируют обнаружение ошибки оператораотношения.</p>
                        <p>Для определения ошибок в Е1 и Е2 тест должен сформировать значение Е1 большим или меньшим, чем Е2, причемобеспечить как можно меньшую разницу между этими значениями.</p>
                        <p>Для булевых выражений с <i>п </i>переменнымитребуется набор из <i>Т </i>тестов. Этот набор позволяет обнаружить ошибкибулевых операторов, переменных и скобок, но практичен только при малом <i>п. </i>Впрочем,если в булево выражение каждая булева переменная входит только один раз, токоличество тестов легко уменьшается.</p>
                        <h3 id="if">Тестирование ветвей и операторов отношений</h3>
                        <p> Способ тестирования ветвей иоператоров отношений (автор К. Таи, 1989) обнаруживает ошибки ветвления иоператоров отношения в условии, для которого выполняются следующие ограничения:</p>
                        <ul>
							<li>все булевы переменные и операторы отношения входят в условие только по одному разу;</li>
							<li>в условии нет общих переменных.</li>
						</ul>
                        <p>В данном способе используютсяестественные ограничения условий (ограничения на результат). Для составногоусловия С, включающего <i>п </i>простых условий, формируется ограничениеусловия:</p>
                        <p><b>ОУ<sub>с</sub>=(d<sub>1</sub>,d<sub>2</sub>,... d<sub>n</sub>),</b></p>
                        <p><i> </i>где <i>di</i><i> — </i>ограничение на результат простого условия. Ограничениена результат фиксирует возможные значения аргумента (переменной) простогоусловия (если он один) или соотношения между значениями аргументов (если ихнесколько).</p>
                        <p>Если i- простое условие являетсябулевой переменной, то его ограничение на результат состоит из двух значений иимеет вид</p>
                        <p><b><i>d<sub>i</sub></i><i> </i>=( true, false).</b></p>
                        <p>Если <i>j</i>-е простое условиеявляется выражением отношения, то его ограничение на результат состоит из трехзначений и имеет следующий вид:</p>
                        <p><b><i>dj</i><i> </i>=(,,=).</b></p>
                        <p>Говорят, что ограничение условия ОУ<sub>С</sub>(для условия С) покрывается выполнением <i>С, </i>если в ходе этого выполнениярезультат каждого простого условия в С удовлетворяет соответствующему ограничениюв ОУ<sub>С</sub>.</p>

                        <p>На основе ограничения условия ОУсоздается ограничивающее множество ОМ, элементы которого являются сочетаниямивсех возможных значений<i>d</i><i><sub>1</sub></i><i><sub>t</sub>
                            </i><i> </i><i>d</i><i><sub>2</sub></i><i>, </i><i>d</i><i><sub>3</sub>
                            </i><i>, ..., </i><i>d<sub>n</sub></i><i>.</i></p>
                        <p>Ограничивающее множество — удобныйинструмент для записи задания на тестирование, ведь оно составляется изсведений о значениях переменных, которые влияют на значение проверяемогоусловия. Поясним это на примере. Положим, надо проверить условие, составленноеиз трех простых условий:</p>
                        <p><b><i>b(ху)а.</i></b></p>
                        <p>Условие принимает истинноезначение, если все простые условия истинны. В терминах значений простых условийэто соответствует записи</p>
                        <p><b>(true, true, true),</b></p>
                        <p>а в терминах ограничений на значения аргументов простых условий — записи</p>
                        <p><b>(true, , true).</b></p>
                        <p>Ясно, что вторая запись являетсяпрямым руководством для написания теста. Она указывает, что переменная
								<i>b</i><i> </i>должна иметь истинное значение, значение переменной <i>х </i>должно быть больше значения переменной
                            y, и, наконец, переменная <i>а </i>должна иметь истинное значение.</p>
                        <p>Итак, каждый элемент ОМ задаетотдельный тестовый вариант. Исходные данные тестового варианта должныобеспечить соответствующую комбинацию значений простых условий, а ожидаемыйрезультат равен значению составного условия.</p>
                        <p>Пример 1. В качестве примера рассмотрим два типовыхсоставных условия:</p>
                        <p><b><i>С<sub></sub> = а </i><i> b</i><i>, С</i><i><sub>or</sub></i><i>=а</i><i> or </i><i>		  
								</i><i>b</i><i></b>, </i> где <i>а и </i><i> b</i><i>—</i> булевы переменные. Соответствующие ограничения условий принимают вид</p>
                        <p><b>OY<sub></sub>= (<i>d</i><i><sub>1</sub></i><i>, </i><i>d</i><i><sub>2</sub></i>) ,OY<sub>or</sub>= (<i>d</i><i><sub>1</sub></i><i>, </i><i>d</i><i><sub>2</sub></i>)</b></p>
                        <p>где <i>d<sub>1</sub></i>=<i>d<sub>2</sub> </i>= (true, false). </p>
                        <p>Ограничивающие множества удобно строить с помощью таблицы истинности (табл. 6.1).</p>
                        <p>Таблица 1. Таблица истинности логических операций </p>
                        <div align=center>
                            <table border=1 cellspacing=0 cellpadding=0 width=522>
								<tr>
									<td>Вариант</td>
									<td><i>а</i></td>
									<td>b</td>
									<td>ab</td>
									<td>a or b</td>
								</tr>
								<tr>
									<td>1</td>
									<td>false</td>
									<td>false</td>
									<td>false</td>
									<td>false</td>
								</tr>
								<tr>
									<td>2</td>
									<td>false</td>
									<td>true</td>
									<td>false</td>
									<td>true</td>
								</tr>
								<tr>
									<td>3</td>
									<td>true</td>
									<td>false</td>
									<td>false</td>
									<td>true</td>
								</tr>
								<tr>
									<td>4</td>
									<td>true</td>
									<td>true</td>
									<td>true</td>
									<td>true</td>
								</tr>
                            </table>

                        </div>

                        <p>Видим, что таблица задает в ОМчетыре элемента (и соответственно, четыре тестовых варианта). Зададим вопрос —каковы возможности минимизации? Можно ли уменьшить количество элементов в ОМ?</p>

                        <p>С точки зрения тестирования, намнадо оценивать влияние составного условия на программу. Составное условие можетпринимать только два значения, но каждое из значений зависит от большогоколичества простых условий. Стоит задача — избавиться от влияния избыточныхсочетаний значений простых условий.</p>

                        <p>Воспользуемся идеей сокращеннойсхемы вычисления — элементы выражения вычисляются до тех пор, пока они влияютна значение выражения. При тестировании необходимо выявить ошибки переключения,то есть ошибки из-за булева оператора, оперируя значениями простых условий (булевыхпеременных). При таком инженерном подходе справедливы следующие выводы </p>

                        <p>для условия типа И <i>(а </i> b<i>) </i>варианты 2 и 3 поглощают вариант 1. Поэтому ограничивающеемножество имеет вид:</p>
                             
							 <p><b>ОМ<sub></sub> = {(false, true), (true, false), (true, true)};</b>
                        </p>

                        <p>для условия типа ИЛИ (a or <i>b
                            </i><i>) </i>варианты 2 и 3 поглощают вариант 4. Поэтому     ограничивающеемножество имеет вид:
							</p>
							<p><b>ОМ
                            or= {(false,false), (false,true), (true,false)}.</b>
                        </p>
                        <p>Рассмотрим шаги способатестирования ветвей и операторов отношений.
                        </p>
                        <p>ДЛЯ каждого условия впрограмме выполняются следующие действия:
                        </p>
						<ul>
							<li>строится ограничение условий ОУ;</li>
							<li>выявляются ограничения результата покаждому простому условию;</li>
							<li>строится ограничивающее множество ОМ. Построениевыполняется путем подстановки в константные формулы ОМ или ОМ<sub>ОГ</sub>выявленных ограничений результата;</li>
							<li>для каждого элемента ОМ разрабатываетсятестовый вариант.</li>
						</ul>
						
                        <p>
                            Примep2. Рассмотрим составноеусловие <i>С<sub>1</sub> </i>вида:</p>

                        <p><b> B<sub>1</sub> (E<sub>1</sub>=E<sub>2
                            </sub>)</b>
                        </p>

                        <p >Где В<sub>1</sub> булево выражение, Е<sub>1</sub>,Е<sub>2</sub><i> —</i>арифметические выражения.</p>

                        <p >
                            Ограничение составного условия имеет вид
                        </p>

                        <p><b>  OY<sub>c</sub> = (<i>d
                            </i><i><sub>1</sub></i><i>,
                            </i><i>d</i><i><sub>    2</sub>
                            </i> )</b
                        </p>

                        <p >
                            где ограничения простых условий равны
                        </p>

                        <p><b>
                            <i>d
                            </i><sub>1</sub>= (true,false),<i>d</i><i><sub>    2</sub>
                            </i><i> = </i>(=, , ) .</b>
                        </p>

                        <p >Проводя аналогию между С<sub>1</sub> и <i>    С<sub></sub></i>(разница лишь в том, что в С<sub>1</sub> второе простое условие — это выражениеотношения), мы можем построить ограничивающее мно­жество для С, модификацией</p>
                        <p ><b>
                            ОМ<sub></sub>- {(false, true), (true, false), (true, true)}.</b>
                        </p>
                        <p >Заметим, чтоtrueдля<i>(</i><i>E<sub>l</sub></i><i>
							</i>=E<sub>2</sub>) означает «,afalseдля (E<sub>1</sub> - E<sub>2</sub>) означает или , или . Заменяя (true, true) и (false, true),ограничениями (true, -) и (false, -) соответствен­но,) — ограничениями (true, ) и (true, ), получаем ограничивающее множество для<i>С<sub>1</sub>,</i>
                        </p>
						
                        <p><b>OM<sub>C1</sub>={(false,=),(true,),(true,),(true,=)}.</b></p>
                        
						<p >Покрытие этого множества гарантирует обнаружение ошибокбулевых операто­ров и операторов отношения в С<sub>1</sub>.</p>
                        <p >Пример 3. Рассмотрим составное условие С<sub>2</sub> вида</p>
                        <p >(E<sub>3</sub> E<sub>4</sub>)(E<sub>1</sub> =E<sub>2</sub>),</p>
                        <p >где E<sub>1</sub>, E<sub>2</sub>,E<sub>3</sub>, E<sub>4</sub>— арифметические выражения.</p>
                        <p >Проводя аналогию между С<sub>2</sub> и С, (разница лишь втом, что в С<sub>2</sub> первое простое условие — это выражение отношения), мыможем построить ограничивающее мно­жество для <i>С<sub>2</sub> </i>модификациейОМ<sub>С</sub>:</p>
                        
						<p><b>ОМ<sub>С2</sub> = {(=, =), (, =), (, ), (,), (, =)}.</b></p>
                        
						<p>Покрытие этого ограничивающего множества гарантируетобнаружение ошибок операторов отношения в С<sub>2</sub>.</p>
                        <p>Способ тестирования потоков данных</p>
                        <p>В предыдущих способах тесты строились на основе анализауправляющей струк­туры программы. В данном способе анализу подвергаетсяинформационная струк­тура программы.</p>
                        <p>Работу любой программы можно рассматривать как обработкупотока данных, передаваемых от входа в программу к ее выходу. Рассмотримпример.</p>
                        <p>Пусть потоковый граф программы имеетвид, представленный на рис. 8. В нем сплошные дуги — это связи по управлениюмежду операторами в программе. Пунктирные дуги отмечают информационные связи(связи по потокам данных).</p>
                        <p>Обозначенные здесь информационные связи соответствуют следующим допущениям:</p>
                        <p>·в вершине 1 определяются значения переменных <i>а, b</i></p>
                        <p>·значение переменной <i>а </i>используется в вершине 4;</p>
                        <p>·значение переменной <i>b</i> используется в вершинах 3, 6;</p>
                        <p>·в вершине 4 определяется значение переменной с, которая используется в вершине 6.</p>
                        <p style='text-align:center'><img width=103 height=204 src="teory/teory2.files/image009.jpg"></p>
                        <p style='text-align:center'>Рис. 6.8. Граф программы с управляющими и информационными связями</p>
                        <p>В общем случае для каждой вершины графа можно записать:</p>
                        <p>множество определений данных DEF(i) - { х | i-я вершинасодержит определение х};</p>
                        <p>множество использований данных:>USE (i) - { х | i -я вершина использует х}.</p>
                        <p>Под <i>определением данных </i>понимают действия,изменяющие элемент данных, Признак определения — имя элемента стоит в левойчасти оператора присваивания: x:= f(…)</p>
                        <p><i>Использование данных — </i>это применение элемента ввыражении, где происходит обращение к элементу данных, но не изменениеэлемента. Признак использования— имя элемента стоит в правой части оператораприсваивания:</p>
                        <p >ИМЯ:= f(х)</p>
                        <p >Здесь ИМЯ -  место подстановки другого имени. </p>
                        <p>Назовем DU –цепочкой конструкцию[x,i,j], где i,j имена
                            вершин;  х определена в i  - вершине и используется в j вершине.</p>
                        <p>В примере существуют следующие DU цепочки:</p>
                        <p><b>[a,1,4], [b,1,3],[b,1,6],[c,4,6].</b></p>
                        <p>Способ DU тестирования требует охвата всех DU-цепочек
                            программы. Разработка теста проводится на основе анализа жизни всех данных
                            программы.</p>
                        <p>Для подготовки тестов требуется выделение маршрутов – путей
                            выполнения программы на управляющем графе. Критерий выбора пути – покрытие
                            максимального количества DU – цепочек.</p>
                        <p>Шаги способа  DU-тестирования:</p>
                        <ol style='margin-top:0cm' start=1 type=1>
                            <li>построение управляющего графа программы;</li>
                            <li>Построение информационного графа;</li>
                            <li>Формирование полного набора DU- цепочек;</li>
                            <li>Формирование полного набора отрезков путей в управляющем графе</li>
                            <li>Построение маршрутов –полных путей на управляющем грае, покрывающих набор отрезковпутей управляющего графа;</li>
                            <li>Подготовка тестовых вариантов.</li>
                        </ol>
						
                        <h3 id="circle">Тестирование циклов</h3>
                        <p><b>Цикл</b> – наиболее распространенная конструкция
                            алгоритмов, реализуемых в программном обеспечении. Тестирование циклов
                            производится по принципу «белого ящика», при проверке циклов основное внимание
                            обращается на правильность конструкций циклов.</p>
                        <p>Различают 4 типа циклов:</p>
						<ol>
							<li>Простые</li>
							<li>Вложенные</li>
							<li>Объединенные</li>
							<li>Неструктурированные</li>
						</ol>
                        <p><b>Простые циклы</b></p>
                        <p>Для проверки простых циклов с количеством повторений <i>п </i>может
                            использоваться один из следующих наборов тестов:</p>
						<ul>
							<li>прогон всего цикла;</li>
							<li>только один проход цикла;</li>
							<li>два прохода цикла;</li>
							<li><i>т </i>проходов цикла, где <i>т  n;</i></li>
							<li><i>n </i>- 1, <i>n, n </i>+ 1 проходов цикла.</li>
						</ul>
                        <p style='text-align:center'><img width=168 height=197 src="teory/teory2.files/image010.jpg"></p>
                        <p style='text-align:center'>Простые циклы</p>
                        <p><b>Вложенные циклы</b></p>
                        <p> С увеличением уровня вложенности циклов количество возможных
                            путей резко возрастает. Это приводит к нереализуемому количеству тестов. Для
                            сокращения количества тестов применяется специальная методика, в которой
                            используются такие понятия, как объемлющий и вложенный циклы.</p>
                        <p style='text-align:center'><img width=138 height=227 src="teory/teory2.files/image011.jpg"></p>
                        <p style='text-align:center'>Вложенные циклы</p>
                        <p>Шаги тестирования:</p>
						<ul>
							<li>Выбирается самый внутренний цикл. Устанавливаются
                            минимальные значения параметров всех остальных циклов.</li>
							<li>Для внутреннего цикла проводятся тесты простого цикла.
                            Добавляются тесты для исключенных значений и значений, выходящих за пределы
                            рабочего диапазона.</li>
							<li>Переходят в следующий по порядку объемлющий цикл.
                            Выполняют его тестирование. При этом сохраняются минимальные значения
                            параметров для всех внешних (объемлющих) циклов и типовые значения для всех
                            вложенных циклов.</li>
						</ul>
                        <p>Работа продолжается до тех пор, пока не будут протестированывсе циклы.</p>
                        <p><b>Объединенные циклы</b></p>
                        <p> Если каждый из циклов независим от других, то используется
                            техника тестирования простых циклов. При наличии зависимости (например,
                            конечное значение счетчика первого цикла используется как начальное значение
                            счетчика второго цикла) используется методика для вложенных циклов.</p>
                        <p style='text-align:center'><img width=84 height=205 src="teory/teory2.files/image012.jpg"></p>
                        <p style='text-align:center'>Объединенные циклы</p>
                        <p><b>Неструктурированные циклы</b></p>
                        <p>Неструктурированные циклы тестированию не подлежат. Этот тип циклов должен быть переделан с помощью структурированных программных конструкций.</p>
                        <p style='text-align:center'><img width=118 height=278 src="teory/teory2.files/image013.jpg"></p>
                        <p style='text-align:center' id="down">Неструктурированные циклы</p>
					</div>
				</div>
            </div>
        </div>
	</body>
</html>
