<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="windows-1251">
    <link rel="stylesheet" href="style.css">
    <link href="Labs/Lab_style.css" rel="stylesheet">
        </head>
        <body>
            <div id="container">
                <div id="navigation">
                    <a href="index.html">
                        <div class="nav_button">
                            <div class="nav_left"><img src="image/home.png"></div>
                            <div class="nav_right one">Главная</div>
                        </div>
                    </a>
                    <a href="info.html">
                        <div class="nav_button">
                            <div class="nav_left"><img src="image/instruct.png"></div>
                            <div class="nav_right one">Инструкции</div>
                        </div>
                    </a>
                    <a href="teory.html">
                        <div class="nav_button"  style="color:#ff6a00">
                            <div class="nav_left"><img src="image/library.png"></div>
                            <div class="nav_right two">Теоретический материал</div>
                        </div>
                    </a>
                    <a href="labs.html">
                        <div class="nav_button">
                             <div class="nav_left"><img src="image/labs.png"></div>
                            <div class="nav_right two">Лабораторные работы</div>
                        </div>
                    </a>
                    <a href="adds.html">
                        <div class="nav_button">
                             <div class="nav_left"><img src="image/lupe.png"></div>
                            <div class="nav_right two">Дополнительные материалы</div>
                        </div>
                    </a>
                </div>
	
				
					<div class="left">
								<!--Навигация внутри страницы (якоря)-->
                    <div class="main header" style="margin: auto;">
                        <h1>Функциональное тестирование</h1>
						<div class="local">
						<a href="#up"><div class="local_nav">Вверх</div></a>
						<a href="#down"><div class="local_nav">Вниз</div></a>
						<div class="local_nav_bord"></div>
						<a href="teory4.html"><div class="local_nav">Следующая тема</div></a>
						<a href="#info"><div class="local_nav">Сбор информации</div></a>
						<a href="#method"><div class="local_nav">Методы</div></a>
						<a href="teory2.html"><div class="local_nav">Предыдущая тема</div></a>
						</div>
                    </div>
                <div class="content" style="overflow: scroll;">
					<div class="incontent">
                    <h1 id="up">Функциональное тестирование</h1>
                    <h2>Определение</h2>
                    <p><b>Функциональное тестирование</b> — это тестирование ПО
                        в целях проверки реализуемости
                        функциональных требований? то есть способности ПО в
                        определённых условиях решать задачи, нужные пользователям. Функциональные
                        требования определяют, что именно делает ПО, какие задачи оно решает.</p>
                    <p>Функциональные требования включают в себя:</p>
					<ol>
						<li>Функциональнаяпригодность (англ.suitability).</li>
						<li>Точность(англ.accuracy).</li>
						<li>Способность к взаимодействию (англ.interoperability).</li>
						<li>Соответствие стандартам и правилам (англ.compliance).</li>
						<li>Защищённость(англ.security).</li>
					</ol>
                    <p>Есть много приложений, для которых производительность и
                        удобство пользования некритичны. Во всяком случае, часто требования к ПО
                        содержат только функциональную часть. И практически не бывает требований к ПО
                        без функциональной части.</p>
                    <p>Как правило, функциональное и нефункциональное тестирование
                        ПО можно проводить параллельно, поэтому обычно это делается разными людьми или
                        командами. В большинстве источников указывается, что функциональное
                        тестирование - это синоним тестирования методом черного ящика.</p>
                    <p><b>Преимущества функционального тестирования</b>:</p>
                    <ul>
                        <li>имитирует фактическое использование системы;</li>
                    </ul>
                    <p><b>Недостатки функционального тестирования</b>:</p>
                    <ul>
						<li>возможность  упущения логических ошибок в программном обеспечении;</li>
                        <li>вероятность избыточного тестирования.</li>
                    </ul>
					
                    <h2 id="method">Методы отбора тестов для тестирования черного ящика</h2>
                    <p>Любая программа может рассматриваться как конечный автомат,
                        с входными и выходными данными, набором внутренних состояний и переходов между
                        ними.</p>
                    <p>Чтобы провести полное тестирование программы, нужно
                        проверить правильность ее поведения при всех возможных комбинациях входных
                        данных и во всех возможных внутренних состояниях. Это довольно трудно сделать
                        из-за огромного числа комбинаций даже в простейших случаях. Поэтому на практике
                        отбираются только наиболее важные тесты, такой отбор можно производить
                        несколькими методами.</p>
                    
					<h3>Тестирование сценариев использования (use-cases)</h3>
                    <p>Чтобы удостовериться в правильности перехода программы между
                        различными внутренними состояниями, в идеале следует протестировать все
                        возможные переходы между каждым из состояний.</p>
                    <p>Чтобы уменьшить число тестов, можно проверить только те
                        переходы, которые имеют смысл для пользователя. Use-case - это логически завершенная последовательность действий.
                        Например, открытие файла в Notepad - это use-case, а выбор пункта меню
                        Открыть файл в Notepad - это не use-case, а лишь первый шаг юз-кейса
                        открытие файла.</p>
                    <p>Тестирование сценариев является самым необходимым видом
                        тестирования. Программа должна выполнять операции, для которых она
                        предназначена. Если пользователь может выбрать пункт меню, но файл не
                        открывается - это очень серьезный баг. Здесь проверяется правильность перехода
                        программы между внутренними состояниями при выполнении определенных операций.</p>
                    <h3>Тестирование классов эквивалентности.</h3>
                    <p>Чтобы удостовериться в правильности поведения программы при
                        различных входных данных, в идеале следует протестировать все возможные значения
                        для каждого элемента этих данных, а также все возможные сочетания входных
                        параметров.</p>
                    <p>Например, пусть мы тестируем программу для отдела кадров, в ней есть поле Возраст соискателя.</p>
                    <p>Требования по возрасту у нас будут такие:</p>
                    <p>0-13 лет - не нанимать</p>
                    <p>14-17 лет - можно нанимать на неполный день</p>
                    <p>18-54 года - можно нанимать на полный день</p>
                    <p>55-99 лет - не нанимать</p>
                    <p>Чтобы проверить все возможные разрешенные данные нам нужно
                        протестировать ввод чисел от 0 до 99. (Возможен ведь еще ввод отрицательных
                        чисел и нечисловых данных.) Так ли необходимо тестировать все числа от 0 до 99?
                        Программы построены на работе с диапазонами значений:</p>
                    <p>if (age = 0  age =13)</p>
                    <p>hireStatus=NO;</p>
                    <p>if (age = 14  age =17)</p>
                    <p>hireStatus=PART;</p>
                    <p>if (age = 18  age =54)</p>
                    <p>hireStatus=FULL;</p>
                    <p>if (age = 55  age =99)</p>
                    <p>hireStatus=NO;</p>
                    <p>Становится очевидным, что можно протестировать одно из чисел
                        каждого диапазона. Например: 5, 15, 20, 60. А также граничные значения: 0, 13,
                        14, 17, 18, 54, 55, 99.</p>
                    <p>Чтобы уменьшить количество тестируемых значений, производится</p>
                    <p>а) разбиение множества всех значений входной переменной на
                        подмножества (классы эквивалентности), а затем</p>
                    <p>б) тестирование одного любого значения из каждого класса.</p>
                    <p>Все значения из каждого подмножества должны быть
                        эквивалентны для наших тестов. То есть, если тест проходит успешно для одного
                        значения из класса эквивалентности, он должен проходить успешно для всех
                        остальных. И наоборот, если тест не проходит для одного значения, он не должен
                        проходить для всех остальных.</p>
                    <p>В данном случае имеем 12 классов эквивалентности (каждое из 8 граничных значений по сути является отдельным классом).</p>
                    <p>Чтобы проверить правильность работы программы на всех
                        разрешенных данных, нужно провести 12 тестов.</p>
                    <p>Запрещенные данные тестируются аналогично - можно выделить
                        классы эквивалентности дробное число от 0 до 99,
                        отрицательное число, число больше 99, набор
                        букв, пустая строка и т.д.</p>
                    <p>Таким образом, метод классов эквивалентности можно разделить
                        на три этапа:</p>
						<ol>
							<li>Тестирование разрешенных значений.</li>
							<li>Тестирование граничных значений.</li>
							<li>Тестирование запрещенных значений.</li>
						</ol>
                    <p>Часто в литературе второй и третий этапы называют отдельными
                        методами, но сути это не меняет.</p>
                    <p>Попарное тестирование.</p>
                    <p>Метод классов эквивалентности применяется для тестирования каждого входного параметра по отдельности.</p>
                    <p>Пусть наша программа принимает на вход десять параметров.
                        Баги, возникающие при определенном сочетании всех десяти параметров, довольно
                        редки. Вообще, взаимное влияние параметров, о котором пользователь не знает -
                        это баг интерфейса.</p>
                    <p>Чаще всего будут встречаться ситуации, в которых один
                        параметр влияет на один из оставшихся, т.е. самыми частыми будут баги,
                        возникающие при определенном сочетании двух каких-то параметров.</p>
                    <p>Таким образом, можно упростить себе задачу и протестировать
                        все возможные значения для каждой из пар параметров. Такой подход называется
                        попарным тестированием (pairwise testing).</p>
                    <p>Вот пример. Пусть имеется 3 двоичных входных параметра (3
                        чекбокса). Количество всех возможных комбинаций - 2 в степени 3 = 8 , значит,
                        нужно произвести 8 тестов. Давайте попробуем сэкономить, тестируя чекбоксы
                        попарно.</p>
                    <p>Выпишем все комбинации для первого и второго чекбоксов:</p>
                    <p> 1-й 2-й</p>
                    <p> 0   0    </p>
                    <p> 0   1 </p>
                    <p> 1   0 </p>
                    <p> 1   1</p>
                    <p>Добавим третий столбец так, чтобы во втором и третьем
                        столбце получились все 4 двоичные комбинации. Это можно сделать разными
                        способами, мы сделаем так (на первый столбец можно не обращать внимания):</p>
                    <p> 1-й 2-й 3-й</p>
                    <p> 0   0   0   </p>
                    <p> 0   1   0</p>
                    <p> 1   0   1</p>
                    <p> 1   1   1</p>
                    <p>Итак, с помощью четырех наборов входных данных (четырех
                        тестов) мы протестируем две пары параметров: первый со вторым и второй с
                        третьим. Осталось протестировать пару первый с третьим.</p>
                    <p>Выпишем отдельно 1 и 3 столбцы:</p>
                    <p> 1-й     3-й</p>
                    <p> 0       0   </p>
                    <p> 0       0</p>
                    <p> 1       1</p>
                    <p> 1       1</p>
                    <p>Как видно, мы имеем здесь две из четырех возможных
                        комбинаций. Комбинации 01 и 10 здесь отсутствуют, а
                        комбинации 00 и 11 присутствуют два раза. Ну что же,
                        добавим еще 2 строки (еще два теста)</p>
                    <p> 1-й     3-й</p>
                    <p> 0       0   </p>
                    <p> 0       0</p>
                    <p> 1       1</p>
                    <p> 1       1</p>
                    <p> 0       1</p>
                    <p> 1       0</p>
                    <p>Вернем второй столбец на его законное место:</p>
                    <p> 1-й 2-й 3-й</p>
                    <p> 0   0   0    </p>
                    <p> 0   1   0</p>
                    <p> 1   0   1</p>
                    <p> 1   1   1</p>
                    <p> 0       1</p>
                    <p> 1       0</p>
                    <p>Выходит, что последние два теста можно проходить при любых
                        значениях второго параметра. Можно дописать для определенности нули в эти
                        пустые места:</p>
                    <p> 1-й 2-й 3-й</p>
                    <p> 0   0   0    </p>
                    <p> 0   1   0</p>
                    <p> 1   0   1</p>
                    <p> 1   1   1</p>
                    <p> 0   0   1</p>
                    <p> 1   0   0</p>
                    <p>Получаем 6 тестов вместо 8 при полном переборе. </p>
                    <p>Можно ли сэкономить еще? Оказывается, можно.</p>
                    <p>Вернемся к 1 шагу:</p>
                    <p> 1-й 2-й</p>
                    <p> 0   0    </p>
                    <p> 0   1 </p>
                    <p> 1   0 </p>
                    <p> 1   1</p>
                    <p>Давайте допишем третий столбец другим способом, поменяв порядок комбинаций:</p>
                    <p> 1-й 2-й 3-й</p>
                    <p> 0   0   1   </p>
                    <p> 0   1   0</p>
                    <p> 1   0   0</p>
                    <p> 1   1   1</p>
                    <p>Все комбинации для 1 и 2, а также для 2 и 3 параметра здесь есть. Отлично.</p>
                    <p>Посмотрим теперь на комбинации 1 и 3 параметра</p>
                    <p> 1-й     3-й</p>
                    <p> 0       1</p>
                    <p> 0       0</p>
                    <p> 1       0</p>
                    <p> 1       1</p>
                    <p>Изменив порядок значений в третьем
                        столбце, мы одним махом убили двух зайцев: скомбинировали и 2-й с 3-м, и 1-й с
                        3-м параметры.</p>
                    <p>Итого имеем всего 4 строки, то есть 4 теста, эквивалентные
                        первоначальным шести:</p>
                    <p> 1-й 2-й 3-й</p>
                    <p> 0   0   1</p>
                    <p> 0   1   0</p>
                    <p> 1   0   0</p>
                    <p> 1   1   1</p>
                    <p>Полный перебор всех комбинаций в третьем столбце
                        гарантированно даст минимальное количество тестов. Однако, судя по тому, что
                        алгоритмы такой минимизации разрабатываются до сих пор, полный перебор
                        неприемлем из-за большого времени исполнения.</p>
                    <p>Вот строгое определение ортогонального массива:</p>
                    <p>Ортогональный массив OA(N,k,s,t) - это двумерный массив из N рядов
                        (итераций) и k колонок (факторов) из набора S (т.е. факторы могут принимать любое из s
                        значений), обладающий свойством:</p>
                    <p>выбрав любые t колонок (0=t=k) мы получим в рядах все
                        комбинации сочетаний из s по t
                        (Количество повторений одинаковых комбинаций обозначают через &#955;.
                        Чаще всего рассматривают массивы, где &#955; = 1, т.е.
                        каждая комбинация встречается только один раз). Параметр t
                        называют мощностью ортогонального массива.</p>
                    <p>В попарном тестировании применяется ортогональный массив
                        мощности 2 - это двумерный массив такой, что любые 2 колонки этого массива
                        содержат все возможные комбинации (пары) значений, хранящихся в массиве.</p>

                    <h2 id="info">Сбор информации о программе при тестировании</h2>
                    <h3>Информация о базе данных</h3>
                    <p>Если программа использует для своей работы какую-либо базу
                        данных, мы можем проанализировать типы полей, в которые записываются переменные
                        программы. А потом проанализировать ограничения, которые накладывает база
                        данных.</p>
                    <p>Например, если вводимая фамилия пользователя  записывается в
                        поле типа строка длиной 128 символов, мы должны:</p>
						<ol>
							<li>Попробовать найти фамилию длиннее, чем 128 символов -
                        здесь будет довольно серьезный баг, если такие фамилии существуют - человек с
                        такой фамилией не сможет воспользоваться нашей системой.</li>
							<li>Вне зависимости от того, существуют или нет такие
                        фамилии, попробовать ввести строку длиннее 128 символов - программа не должна
                        ломаться (должно показываться внятное сообщение об ошибке)</li>
						</ol>
						
                    <h3>Информация о других внешних системах</h3>
                    <p>Если программа интегрируется с другими внешними системами,
                        помимо базы данных, можно также проанализировать ограничения таких систем.
                        Например, если мы тестируем почтовый IMAP-клиент,
                        следует убедиться, что он корректно обрабатывает длинные пути к папкам на
                        сервере (чаще всего, ограничение на длину пути составляет 255 символов)</p>
                    
					<h3>Информация о коде программы</h3>
                    <p>Если мы имеем доступ к коду программы, мы можем:</p>
					<ol>
						<li>Увидеть специальные случаи, которые не попали в документ
                        с требованиями и которые необходимо протестировать или, напротив.</li>
						<li>Увидеть, что какие-то вещи тестировать не имеет смысла.</li>
					</ol>
					
                    <h3>Как протестировать неизвестную программу или наращиваемый
                            подход к первичному функциональному тестированию ПО.</h3>
                    <p><b>Первичное тестирование</b> - это тестирование нового ПО,
                        проводимое в первый раз. Первичное тестирование имеет смысл совмещать с
                        написанием тестовой документации, потому что тестовая документация пригодится
                        для контроля того, что сделано и в какие сроки, а также для последующего
                        регрессионного тестирования этой функциональности.</p>
                    <p>Обычно требуется получить результаты тестирования как можно
                        раньше, а написание тестовой документации требует довольно много времени.
                        Поэтому имеет смысл сначала написать черновик (список тестов с временны'ми
                        оценками на их проведение), потом по этому черновику провести собственно
                        тестирование (в ходе которого черновик может корректироваться), а после выдачи
                        результатов тестирования уже можно написать чистовик. Эту задачу можно поручить
                        отдельному человеку.</p>
                    <p>Поскольку в ходе тестирования в черновик могут вноситься
                        изменения, в оценки нужно закладывать некоторый запас по времени (на запас
                        больше, чем в 2 раза, руководство обычно не соглашается).</p>
					<p>Наращиваемый подход заключается в следующем. Тестирование
                        полезно разбить на этапы в порядке уменьшения значимости. При нехватке времени
                        последние этапы можно пропустить.</p>
                    <p>Один из таких подходов приведен Луизой Тамре в книге
                        Введение в тестирование программного обеспечения. Основываясь на
                        этой книге и собственном опыте, предлагаю следующие этапы первичного
                        тестирования нового ПО или новой функциональности в известном ПО:</p>
						<ol>
							<li>Приемочное тестирование требований к ПО.</li>
							<li>Тестирование базовых сценариев.</li>
							<li>Анализ тенденций.</li>
							<li>Поэлементное тестирование входных данных (тестирование
                        каждого элемента данных в отдельности на всех разрешенных классах эквивалентности).</li>
							<li>Комбинирование входных данных (тестирование комбинаций
                        разрешенных значений для нескольких элементов данных).</li>
							<li>Тестирование граничных значений.</li>
							<li>Тестирование ошибочных данных.</li>
						</ol>

						<h2>Приемочное тестирование требований</h2>
                    <p><b>Приемочное тестирование</b> - это минимально необходимое. Можно
                        придумать множество требований к требования. С точки зрения автора, QA должно обращать внимание в первую очередь на:</p>
						<ol>
							<li>Наличие.</li>
							<li>Непротиворечивость.</li>
							<li>Проверяемость.</li>
							<li>Полноту системы операций (create,read, update, delete).</li>
						</ol>
						
                    <p>В требованиях должны присутствовать эти операции над
                        объектами каждого типа из доступных в пользовательском интерфейсе.</p>
                    <p>Другие требования должны проверяться другими людьми.</p>
                    <p>Актуальность должна проверяться людьми, непосредственно
                        контактирующими с заказчиком и бизнес-индустрией, выполнимость -
                        разработчиками.</p>
                    <p>Если документ с требованиями не прошел приемочное
                        тестирование и исправлять его никто не будет, тогда требованиями к ПО будет
                        фактически являться тестовая документация, которую мы напишем.</p>

                    <h2>Тестирование базовых сценариев</h2>
                    <p>На этом этапе нужно проверить все базовые сценарии,
                        описанные в требованиях, при типичных или дефолтных настройках. Если
                        пользоваться моделью конечного автомата в виде графа, таким образом мы проверим
                        наиболее важные пути в графе.</p>
                    <p>Кроме того, мы должны протестировать операции CRUD над всеми объектами программы (или ее части, если мы
                        тестируем новую функциональность для существующего ПО), с типичными или
                        дефолтными настройками.</p>
                    
					<h2>Поэлементное тестирование входных данных</h2>
                    <p>Определить элементы входных данных (все поля ввода) </p>
                    <p>Определить классы эквивалентности для каждого элемента
                        данных, и выбрать классы, соответствующие валидным значениям.</p>
                    <p>Протестировать программу для каждого элемента в
                        отдельности, в каждом из разрешенных состояний. </p>
                    <p>Этот этап позволяет убедиться, что каждое разрешенное
                        состояние каждого элемента тестируется хотя бы один раз.</p>
                    <p>Например, пусть при создании какого-нибудь объекта в
                        интерфейсе программы имеется 5 чекбоксов. Нужно проверить что каждый чекбокс в
                        отдельности работает, т.е. провести 10 тестов.</p>
                    <p>Пользовательские объекты бывают связаны между собой довольно
                        сложным образом. При тестировании следует помнить о проверке вложенных или иным
                        образом связанных объектов. Например, у одного пользовательского аккаунта в
                        системе управления хостингом может быть несколько подписок с различными
                        сервисами, в том числе с почтовыми ящиками. Пусть также определены операции
                        удаления ящиков, подписок и аккаунта. Соответственно, при удалении подписок и
                        аккаунта следует протестировать, что почтовые ящики и связанные с ними сервисы
                        были удалены.</p>
                    <p>На этом этапе возникают тем большие сложности, чем более
                        сложна тестируемая программа. Для улучшения понимания целесообразно составить
                        схему пользовательских объектов и связей между ними.</p>

                    <h2>Комбинирование входных данных.</h2>
                    <p>Определить и протестировать комбинации разрешенных значений для нескольких элементов данных.</p>
                    <p>Все комбинации проверить невозможно, нужно выбрать самые
                        распространенные и потенциально влияющие друг на друга.  </p>
                    <p>Сюда же следует отнести тестирование при разных глобальных
                        настройках, которые тоже следует считать входными параметрами.</p>

                    <h2>Тестирование граничных значений.</h2>
                    <p>Для каждой границы каждого элемента данных нужно протестировать 2 значения</p>
                    <p>Можно выделить 2 границы:</p>
                    <p>Границы диапазона данных</p>
                    <p>Границы размера поля (длина строки)</p>
                    
					<h2>Тестирование невалидных данных (не имеющих смысла)</h2>
                    <p>Пустая строка </p>
                    <p>Неверные числовые данные (напр., отрицательные или дробные, там где это не имеет смысла)</p>
                    <p>Недопустимый формат (например, для даты или телефона)</p>
                    <p>Недопустимые печатные символы (служебные или национальные символы там, где это не имеет смысла)</p>
                    <p>Недопустимые непечатные символы (перевод строки или табуляция там, где это не имеет смысла)</p>
					
                    <h2>Пример</h2>
                    <p>В качестве примера рассмотрим калькулятор с возможностью основных операций.</p>
                    <p style="text-align:center"><p style='text-align:center;'><img border=0 width=154 height=233 src="teory/teory3.files/image001.gif"></p>
					
					<ol>
						<li><b>Базовые сценарии (операции CRUD)</b><p>В данном случае имеется возможность создание новой записи,
                        редактирование и удаление. Получение информации не возможно.</p></li>
						<li><b>Поэлементное тестирование входных данных</b></li>
							<ol>
								<li><b>Имеется поле ввода</b></li>
								<li><b>Классы эквивалентности для валидных значений:</b>
									<p>Операторы:</p>
									<ul>
										<li>Сложение.</li>
										<li>Вычитание.</li>
										<li>Умножение.</li>
										<li>Деление.</li>
									</ul>
									<p>Операнды:</p></li>
									<ul>
										<li>Простые.</li>
										<li>С плавающей запятой.</li>
									</ul>
									</li>
							</ol>
								<p>Всего получается 6 классов эквивалентности.</p>
								<p>В дополнение имеется возможность очищать форму.</p>
								<p>Так как от перемены зависимость от типа операнда не имеет
									значения, то в одном тесте можно проверять сразу ввод первого и второго типа
									операнда.</p>
								<p>Так как имеется кнопка очищения формы, то ее необходимо
									проверить, но так как ее придется использовать для подготовки программы при
									переходе от первого ко второму тесту, то ее отнесем к первому тесту.</p>
								<p>Итого получается 5 тестов.</p>
								
								
						<li><b>Комбинирование входных данных.</b>
                    <p>Ввод простого числа и числа с плавающей запятой.</p></li>
					
						<li><b>Тестирование граничных значений</b>
                    <p>Получение значения выходящего за рамки максимального числа,
                        которое можно ввести в поле (максимум 10 символов, умножаем число состоящее из
                        10 символов на 10).</p></li>
						<li><b>Тестирование невалидных данных.</b>
							<ol>
								<li><b>Ввод второй плавающей запятой.</b></li>
								<li><b>Деление на ноль.</b></li>
								<li><b>Вставка недопустимых символов из буфера обмена.</b></li>
								<li id="down"><b>Действие с пустым полем.</b></li>
							</ol>
						</li>
					</ol>
				</div>
				<div>
			</div>
        </div>
    </body>
</html>
